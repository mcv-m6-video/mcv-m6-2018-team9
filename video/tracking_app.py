import collections
import time
import cv2
import numpy as np

from video import tracking


class TrackingApplication:
    """Vehicle tracking, speed detection and several additional metrics

    The application take the information generated from Kalman tracker and the
    speed stimator, and generate a board (= image) with:

    - The current frame of the video sequence
    - The speed of each detected cars and their bounding boxes.
    - Some statistics: total vehicles detected, nÂº vehicles in the current
      scene, vehicles/min rate.

    """
    def __init__(self, frame_size, fps, detection_area, low_speed=60,
                 high_speed=120):
        """Create the application

        Once created, use process_input() to update the tracking information
        and generate the output, which is an image for each invocation.
        Therefore, the output can be gathered as a sequence of images to create
        a video or a GIF animation.

        Args:
          frame_size: tuple (h, w) specifying the size of the frames which will
            be passed to the process_input() function.
          fps: (int|float) frames per second for the video sequence to be
            process by the application.
          detection_area: tuple (p1, p2, p3, p4) of points defining the area
            of detection. Any vehicle outside this area is ignored.
          low_speed, high_speed: (int) defines the range for the normal
            speed. Any velocity above or below will be considered anomalous and
            reported to the user.

        """
        self.detection_area = detection_area

        # Speed settings
        self.low_speed = low_speed
        self.high_speed = high_speed

        # Counters and metrics
        self.vehicles = 0
        self.current_vehicles = 0
        self.total_frames = 0
        self.fps = fps

        # Internal objects
        self._tracks = {}  # store all vehicles tracked so far

        # User interface
        frame_height, frame_width = frame_size
        canvas_height = frame_height
        canvas_width = frame_width + 200
        self._canvas = np.ones([canvas_height, canvas_width, 3],
                               dtype='uint8') * 255
        self._canvas_frame = self._canvas[:, :frame_width]
        self._canvas_board = self._canvas[:, frame_width:]

    def process_input(self, frame_im, tracker_detections):
        """Process a new input to generate the application output

        For each new frame, the application expect the corresponding image and
        the information of the tracker and speed detector. With this
        information, generates a new output image containing the image frame
        with bounding boxes and speed estimation for the detected vehicles, and
        a board on the right side with global statistics.

        Args:
          frame_im: numpy array with the current frame of a video sequence.
          tracker_detections: detections generated by kalman tracker.

        Returns:
          The output image. The output images can be collected to build a new
          video.

        """
        tracker_detections = self._filter_visible_tracks(tracker_detections)
        self._update_metrics(tracker_detections)
        self._update_canvas_frame(frame_im, tracker_detections)
        self._update_canvas_board()
        return self._canvas.copy()

    def _update_metrics(self, tracker_detections):
        """Update internal state with the info provided by the KalmanTracker"""
        # update self._tracks
        for pred in tracker_detections:
            key = pred['id']  # we use kalman id as keys in self._tracks dict

            if key in self._tracks:  # vehicle already tracked
                # update track info
                track = self._tracks[key]
                track.update(pred)

            else:                           # new vehicle -> create track
                track = VehicleTrack(pred)
                self._tracks[key] = track

        self.vehicles = len(self._tracks.values())
        self.current_vehicles = len(tracker_detections)
        self.total_frames += 1

    def _update_canvas_frame(self, frame, tracker_detections):
        """Update to last frame with bounding box and labels for current vehicles"""
        if frame.shape[2] == 1:
            im = np.repeat(frame, 3, axis=2)
        else:
            im = frame.copy()  # assuming 3-channel image

        roi = np.reshape(self.detection_area, (1, -1, 1, 2))
        im = cv2.polylines(im, roi, True, (240, 30, 0), 1, cv2.LINE_AA)

        for detection in tracker_detections:
            w = int(detection['size'][0])
            h = int(detection['size'][1])
            x = int(detection['centroid'][0] - w / 2)
            y = int(detection['centroid'][1] - h / 2)
            text = '{} {}'.format(detection['label'], detection.get('text', ''))
            color = (255, 153, 0)
            cv2.rectangle(im, (x,y), (x+w, y+h), color, 1)
            cv2.putText(im, text, (x,y), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color,
                        1, cv2.LINE_AA)

        self._canvas_frame[:] = im

    def _update_canvas_board(self):
        """Update metrics board with the current information"""
        color = (10, 10, 10)

        # Clear board
        self._canvas_board[:] = (255, 255, 255)

        # Current vehicles
        current_vehicles = f"{self.current_vehicles} current vehicles"
        cv2.putText(self._canvas_board, current_vehicles, (5, 20),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1, cv2.LINE_AA)
        # Global counter
        global_counter = f"{self.vehicles} total vehicles"
        cv2.putText(self._canvas_board, global_counter, (5, 60),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1, cv2.LINE_AA)
        # Vehicles per minute
        elapsed_seconds = (1 / self.fps) * self.total_frames
        vehicles_per_minute = (self.vehicles / elapsed_seconds) * 60
        global_counter = f"{vehicles_per_minute:03.0f} vehicles/min"
        cv2.putText(self._canvas_board, global_counter, (5, 100),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1, cv2.LINE_AA)

    def _filter_visible_tracks(self, tracker_detections):
        return [track for track in tracker_detections if
                tracking.point_inside(track['centroid'], self.detection_area)]


class VehicleTrack:
    """Internal class which contains the information for a vehicle track. """
    _global_id_counter = 0

    def __init__(self, kalman_track):
        VehicleTrack._global_id_counter += 1
        self.id = VehicleTrack._global_id_counter
        self.kalman_id = kalman_track['id']   # internal, use self.id instead
        self.centroid_list = [kalman_track['centroid']]
        #self.motion_list = [kalman_track['speed']]  # TODO

    def update(self, kalman_track):
        self.centroid_list.append(kalman_track['centroid'])
        #self.motion_list.append(kalman_track['speed']) # TODO
